"""Unit tests for db/util.py functions."""

from unittest.mock import Mock, patch

import alembic.config
import pytest
from alembic.util import AutogenerateDiffsDetected
from sqlalchemy import Engine
from sqlmodel import Field, Session

from friendly_computing_machine.db.util import (
    SessionManager,
    db_update,
    get_engine,
    init_engine,
    validate_model_fields,
    validate_model_fields_list,
)
from friendly_computing_machine.models.base import Base


class TestModelForTesting(Base, table=True):
    """Test model for unit testing."""

    __tablename__ = "test_model"

    id: int = Field(primary_key=True)
    name: str
    age: int | None = None
    email: str | None = None


class TestValidateModelFields:
    """Test the validate_model_fields function."""

    def test_all_valid_fields(self):
        """Test when all update fields are valid."""
        updates = {"name": "John", "age": 30, "email": "john@example.com"}

        valid_updates, invalid_updates = validate_model_fields(
            TestModelForTesting, updates
        )

        assert valid_updates == updates
        assert invalid_updates == {}

    def test_some_invalid_fields(self):
        """Test when some update fields are invalid."""
        updates = {
            "name": "John",  # valid
            "age": 30,  # valid
            "invalid_field": "value",  # invalid
            "another_invalid": 123,  # invalid
        }

        valid_updates, invalid_updates = validate_model_fields(
            TestModelForTesting, updates
        )

        assert valid_updates == {"name": "John", "age": 30}
        assert invalid_updates == {"invalid_field": "value", "another_invalid": 123}

    def test_all_invalid_fields(self):
        """Test when all update fields are invalid."""
        updates = {"invalid_field": "value", "another_invalid": 123}

        valid_updates, invalid_updates = validate_model_fields(
            TestModelForTesting, updates
        )

        assert valid_updates == {}
        assert invalid_updates == updates

    def test_empty_updates(self):
        """Test with empty updates dictionary."""
        updates = {}

        valid_updates, invalid_updates = validate_model_fields(
            TestModelForTesting, updates
        )

        assert valid_updates == {}
        assert invalid_updates == {}

    @patch("friendly_computing_machine.db.util.logger")
    def test_logs_warning_for_invalid_fields(self, mock_logger):
        """Test that warning is logged for invalid fields."""
        updates = {"name": "John", "invalid_field": "value"}

        validate_model_fields(TestModelForTesting, updates)

        mock_logger.warning.assert_called_once_with(
            "Invalid updates for %s: %s",
            "TestModelForTesting",
            {"invalid_field": "value"},
        )

    @patch("friendly_computing_machine.db.util.logger")
    def test_no_warning_for_all_valid_fields(self, mock_logger):
        """Test that no warning is logged when all fields are valid."""
        updates = {"name": "John", "age": 30}

        validate_model_fields(TestModelForTesting, updates)

        mock_logger.warning.assert_not_called()


class TestValidateModelFieldsList:
    """Test the validate_model_fields_list function."""

    def test_not_implemented(self):
        """Test that the function raises NotImplementedError."""
        with pytest.raises(
            NotImplementedError,
            match="validate_model_fields_list is not implemented yet",
        ):
            validate_model_fields_list(TestModelForTesting, [])


class TestDbUpdate:
    """Test the db_update function."""

    def test_successful_update(self):
        """Test successful update of a model instance."""
        # Setup
        mock_session = Mock(spec=Session)
        mock_instance = Mock(spec=TestModelForTesting)
        mock_instance.id = 1
        mock_session.get.return_value = mock_instance

        updates = {"name": "John", "age": 30}

        with patch(
            "friendly_computing_machine.db.util.validate_model_fields"
        ) as mock_validate:
            mock_validate.return_value = (updates, {})

            result = db_update(mock_session, TestModelForTesting, 1, updates)

            # Assertions
            mock_validate.assert_called_once_with(TestModelForTesting, updates)
            mock_session.get.assert_called_once_with(TestModelForTesting, 1)

            # Check that setattr was called for each update
            assert hasattr(mock_instance, "name")
            assert hasattr(mock_instance, "age")

            mock_session.commit.assert_called_once()
            mock_session.refresh.assert_called_once_with(mock_instance)
            assert result == mock_instance

    @patch("friendly_computing_machine.db.util.logger")
    def test_no_valid_updates(self, mock_logger):
        """Test when there are no valid updates."""
        mock_session = Mock(spec=Session)
        updates = {"invalid_field": "value"}

        with patch(
            "friendly_computing_machine.db.util.validate_model_fields"
        ) as mock_validate:
            mock_validate.return_value = ({}, {"invalid_field": "value"})

            result = db_update(mock_session, TestModelForTesting, 1, updates)

            mock_logger.info.assert_called_once_with(
                "No valid updates for %s", "TestModelForTesting"
            )
            mock_session.get.assert_not_called()
            assert result is None

    @patch("friendly_computing_machine.db.util.logger")
    def test_instance_not_found(self, mock_logger):
        """Test when the instance is not found."""
        mock_session = Mock(spec=Session)
        mock_session.get.return_value = None

        updates = {"name": "John"}

        with patch(
            "friendly_computing_machine.db.util.validate_model_fields"
        ) as mock_validate:
            mock_validate.return_value = (updates, {})

            result = db_update(mock_session, TestModelForTesting, 999, updates)

            mock_session.get.assert_called_once_with(TestModelForTesting, 999)
            mock_logger.info.assert_called_once_with(
                "Instance not found for %s with id=%s", "TestModelForTesting", 999
            )
            mock_session.commit.assert_not_called()
            assert result is None

    def test_attributes_updated_correctly(self):
        """Test that attributes are updated correctly on the instance."""
        mock_session = Mock(spec=Session)
        mock_instance = Mock(spec=TestModelForTesting)
        mock_session.get.return_value = mock_instance

        updates = {"name": "Alice", "age": 25}

        with patch(
            "friendly_computing_machine.db.util.validate_model_fields"
        ) as mock_validate:
            mock_validate.return_value = (updates, {})

            db_update(mock_session, TestModelForTesting, 1, updates)

            # Check that attributes were set correctly on the instance
            assert mock_instance.name == "Alice"
            assert mock_instance.age == 25


class TestSessionManager:
    """Test the SessionManager class."""

    @patch("friendly_computing_machine.db.util.get_engine")
    @patch("friendly_computing_machine.db.util.Session")
    def test_init_without_session(self, mock_session_class, mock_get_engine):
        """Test SessionManager initialization without providing a session."""
        mock_engine = Mock(spec=Engine)
        mock_get_engine.return_value = mock_engine
        mock_session_instance = Mock(spec=Session)
        mock_session_class.return_value = mock_session_instance

        sm = SessionManager()

        assert sm.should_close is True
        assert sm.session == mock_session_instance
        mock_session_class.assert_called_once_with(mock_engine)

    def test_init_with_session(self):
        """Test SessionManager initialization with provided session."""
        provided_session = Mock(spec=Session)

        sm = SessionManager(session=provided_session)

        assert sm.should_close is False
        assert sm.session == provided_session

    def test_enter(self):
        """Test the __enter__ method."""
        mock_session = Mock(spec=Session)
        sm = SessionManager(session=mock_session)

        result = sm.__enter__()

        assert result == mock_session

    @patch("friendly_computing_machine.db.util.get_engine")
    def test_exit_should_close(self, mock_get_engine):
        """Test __exit__ when should_close is True."""
        mock_engine = Mock(spec=Engine)
        mock_get_engine.return_value = mock_engine
        mock_session = Mock(spec=Session)
        sm = SessionManager()
        sm.session = mock_session
        sm.should_close = True

        sm.__exit__(None, None, None)

        mock_session.close.assert_called_once()

    @patch("friendly_computing_machine.db.util.logger")
    def test_exit_should_not_close(self, mock_logger):
        """Test __exit__ when should_close is False."""
        mock_session = Mock(spec=Session)
        sm = SessionManager(session=mock_session)
        sm.should_close = False

        sm.__exit__(None, None, None)

        mock_session.close.assert_not_called()
        mock_logger.debug.assert_called_once_with("session is passthrough, not closing")

    @patch("friendly_computing_machine.db.util.get_engine")
    def test_exit_session_none_raises_error(self, mock_get_engine):
        """Test that __exit__ raises error when session is None."""
        mock_engine = Mock(spec=Engine)
        mock_get_engine.return_value = mock_engine
        sm = SessionManager()
        sm.session = None

        with pytest.raises(
            RuntimeError, match="session is none, exit called without init"
        ):
            sm.__exit__(None, None, None)

    @patch("friendly_computing_machine.db.util.get_engine")
    @patch("friendly_computing_machine.db.util.Session")
    def test_context_manager_full_cycle(self, mock_session_class, mock_get_engine):
        """Test the full context manager cycle."""
        mock_engine = Mock(spec=Engine)
        mock_get_engine.return_value = mock_engine
        mock_session_instance = Mock(spec=Session)
        mock_session_class.return_value = mock_session_instance

        with SessionManager() as session:
            assert session == mock_session_instance

        mock_session_instance.close.assert_called_once()


class TestEngineManagement:
    """Test engine management functions."""

    @patch("friendly_computing_machine.db.util.__GLOBALS", {"engine": None})
    def test_get_engine_when_not_initialized(self):
        """Test get_engine raises error when engine is not initialized."""
        with pytest.raises(RuntimeError, match="engine is none"):
            get_engine()

    @patch("friendly_computing_machine.db.util.__GLOBALS")
    def test_get_engine_when_initialized(self, mock_globals):
        """Test get_engine returns the engine when initialized."""
        mock_engine = Mock(spec=Engine)
        mock_globals.__getitem__.return_value = mock_engine

        result = get_engine()

        assert result == mock_engine
        # The function calls __GLOBALS["engine"] once, but the assertion also calls it
        # So we just check that it was called with "engine"
        mock_globals.__getitem__.assert_called_with("engine")

    @patch("friendly_computing_machine.db.util.__GLOBALS", {"engine": None})
    @patch("friendly_computing_machine.db.util.logger")
    def test_init_engine_success(self, mock_logger):
        """Test successful engine initialization."""
        mock_engine = Mock(spec=Engine)

        init_engine(mock_engine)

        mock_logger.info.assert_called_once_with("engine singleton created")

    @patch("friendly_computing_machine.db.util.__GLOBALS")
    def test_init_engine_already_initialized(self, mock_globals):
        """Test init_engine raises error when engine already initialized."""
        mock_engine1 = Mock(spec=Engine)
        mock_engine2 = Mock(spec=Engine)

        # Configure mock to return an existing engine
        mock_globals.__getitem__.return_value = mock_engine1

        with pytest.raises(RuntimeError, match="engine already initialized"):
            init_engine(mock_engine2)

        mock_globals.__getitem__.assert_called_once_with("engine")


class TestAlembicFunctions:
    """Test alembic-related functions."""

    @patch("friendly_computing_machine.db.util.alembic.command")
    def test_run_downgrade(self, mock_alembic_command):
        """Test run_downgrade function."""
        from friendly_computing_machine.db.util import run_downgrade

        mock_engine = Mock(spec=Engine)
        mock_connection = Mock()
        mock_context_manager = Mock()
        mock_context_manager.__enter__ = Mock(return_value=mock_connection)
        mock_context_manager.__exit__ = Mock(return_value=None)
        mock_engine.begin.return_value = mock_context_manager
        mock_config = Mock(spec=alembic.config.Config)
        mock_config.attributes = {}  # Make it support item assignment
        revision = "abc123"

        run_downgrade(mock_engine, mock_config, revision)

        mock_engine.begin.assert_called_once()
        assert mock_config.attributes["connection"] == mock_connection
        mock_alembic_command.downgrade.assert_called_once_with(mock_config, revision)

    @patch("friendly_computing_machine.db.util.should_run_migration")
    @patch("friendly_computing_machine.db.util.alembic.command")
    @patch("friendly_computing_machine.db.util.logger")
    def test_create_migration_no_migration_required(
        self, mock_logger, mock_alembic_command, mock_should_run
    ):
        """Test create_migration when no migration is required."""
        from friendly_computing_machine.db.util import create_migration

        mock_engine = Mock(spec=Engine)
        mock_config = Mock(spec=alembic.config.Config)
        mock_should_run.return_value = False

        with pytest.raises(RuntimeError, match="no migration required"):
            create_migration(mock_engine, mock_config, "test message")

        mock_logger.info.assert_called_once_with("no migration required")
        mock_alembic_command.revision.assert_not_called()

    @patch("friendly_computing_machine.db.util.should_run_migration")
    @patch("friendly_computing_machine.db.util.alembic.command")
    def test_create_migration_success(self, mock_alembic_command, mock_should_run):
        """Test successful migration creation."""
        from friendly_computing_machine.db.util import create_migration

        mock_engine = Mock(spec=Engine)
        mock_connection = Mock()
        mock_context_manager = Mock()
        mock_context_manager.__enter__ = Mock(return_value=mock_connection)
        mock_context_manager.__exit__ = Mock(return_value=None)
        mock_engine.begin.return_value = mock_context_manager
        mock_config = Mock(spec=alembic.config.Config)
        mock_config.attributes = {}  # Make it support item assignment
        mock_should_run.return_value = True
        message = "test migration"

        create_migration(mock_engine, mock_config, message)

        mock_engine.begin.assert_called_once()
        assert mock_config.attributes["connection"] == mock_connection
        mock_alembic_command.revision.assert_called_once_with(
            mock_config, message=message, autogenerate=True
        )

    @patch("friendly_computing_machine.db.util.alembic.command")
    def test_run_migration(self, mock_alembic_command):
        """Test run_migration function."""
        from friendly_computing_machine.db.util import run_migration

        mock_engine = Mock(spec=Engine)
        mock_connection = Mock()
        mock_context_manager = Mock()
        mock_context_manager.__enter__ = Mock(return_value=mock_connection)
        mock_context_manager.__exit__ = Mock(return_value=None)
        mock_engine.begin.return_value = mock_context_manager
        mock_config = Mock(spec=alembic.config.Config)
        mock_config.attributes = {}  # Make it support item assignment

        run_migration(mock_engine, mock_config)

        mock_engine.begin.assert_called_once()
        assert mock_config.attributes["connection"] == mock_connection
        mock_alembic_command.upgrade.assert_called_once_with(mock_config, "head")

    @patch("friendly_computing_machine.db.util.alembic.command")
    def test_should_run_migration_needed(self, mock_alembic_command):
        """Test should_run_migration when migration is needed."""
        from friendly_computing_machine.db.util import should_run_migration

        mock_engine = Mock(spec=Engine)
        mock_connection = Mock()
        mock_context_manager = Mock()
        mock_context_manager.__enter__ = Mock(return_value=mock_connection)
        mock_context_manager.__exit__ = Mock(return_value=None)
        mock_engine.begin.return_value = mock_context_manager
        mock_config = Mock(spec=alembic.config.Config)
        mock_config.attributes = {}  # Make it support item assignment

        # Simulate AutogenerateDiffsDetected exception
        mock_alembic_command.check.side_effect = AutogenerateDiffsDetected()

        result = should_run_migration(mock_engine, mock_config)

        assert result is True
        mock_engine.begin.assert_called_once()
        assert mock_config.attributes["connection"] == mock_connection
        mock_alembic_command.check.assert_called_once_with(mock_config)

    @patch("friendly_computing_machine.db.util.alembic.command")
    def test_should_run_migration_not_needed(self, mock_alembic_command):
        """Test should_run_migration when no migration is needed."""
        from friendly_computing_machine.db.util import should_run_migration

        mock_engine = Mock(spec=Engine)
        mock_connection = Mock()
        mock_context_manager = Mock()
        mock_context_manager.__enter__ = Mock(return_value=mock_connection)
        mock_context_manager.__exit__ = Mock(return_value=None)
        mock_engine.begin.return_value = mock_context_manager
        mock_config = Mock(spec=alembic.config.Config)
        mock_config.attributes = {}  # Make it support item assignment

        # No exception means no migration needed
        mock_alembic_command.check.return_value = None

        result = should_run_migration(mock_engine, mock_config)

        assert result is False
        mock_engine.begin.assert_called_once()
        assert mock_config.attributes["connection"] == mock_connection
        mock_alembic_command.check.assert_called_once_with(mock_config)
